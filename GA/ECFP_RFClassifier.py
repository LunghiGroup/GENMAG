import numpy as np
# import csv
# import rdkit
import pandas as pd 
# import joblib
# import os 
from rdkit import Chem
from rdkit.Chem import DataStructs, rdFingerprintGenerator
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
import timeit 
starttime = timeit.default_timer()
RANDOM_STATE = 55 ## We will pass it to every sklearn call so we ensure reproducibility


def is_transition_metal(at):
    """     
    Checks if an atom is a transition metal
    """
    n = at.GetAtomicNum()
    return (n>=22 and n<=29) or (n>=40 and n<=47) or (n>=72 and n<=79)

def set_dative_bonds(mol):
    """ 
    Author: Greg Landrum
    Source: https://gist.github.com/greglandrum/6cd7aadcdedb1ebcafa9537e8a47e3a4
    
    Identifies and flags the dative bonds
    Replaces all the bonds between the tranistion metal and atoms with dative bonds. 

    Paramters: 
    mol contains the graph_based information of a molecule. It is automatically generated by RDKit. 

    Returns:
    A modified version of the mol files where the dative bonds are now also included.    
    """
    pt = Chem.GetPeriodicTable()
    rwmol = Chem.RWMol(mol)
    rwmol.UpdatePropertyCache(strict=False)
    metals = [at for at in rwmol.GetAtoms() if is_transition_metal(at)]
    for metal in metals:
        for nbr in metal.GetNeighbors():
            rwmol.RemoveBond(nbr.GetIdx(),metal.GetIdx())
            rwmol.AddBond(nbr.GetIdx(),metal.GetIdx(),Chem.BondType.DATIVE)
    return rwmol      

def mol_assemble(smile1,smile2,fpSize,radius):
    """
    Recieves the smile string for individual ligands, generates the coordination compounds and the 
    corresponding smile string and the ECFP fingerprint to be later used in the RandomForestClassifier model. 

    Parameters:
    smile1, smile2 (str): The ligands' smile string.
    ECFP_files_path (str): The directory path where the fingerprint and smiles files are stored.

    Returns:
    fingerprints of the coordination compounds. 
    """
    try:
        string = '[Co+2]({})({})({})({})'.format(smile1,smile1,smile2,smile2)
        mol = Chem.MolFromSmiles(string,sanitize=False)
        mol_w_dative = set_dative_bonds(mol)
        fmgen = rdFingerprintGenerator.GetMorganGenerator(radius=radius,
                                                          fpSize=fpSize,
                                                          atomInvariantsGenerator=rdFingerprintGenerator.GetMorganFeatureAtomInvGen())
        fp_mol = fmgen.GetFingerprint(mol_w_dative)
        vec = np.zeros((0,), dtype=np.int8)
        DataStructs.ConvertToNumpyArray(fp_mol, vec)
        return vec #, string
    except Exception as e: 
        print(e)


def true_predict(x,y,RF_model,cls_target):
    """
    Identifies the correctly predicted elements within a targeted class. 

    Parameters: 
    x, y (array of int): The dataset over which we observe the ml prediction. 
    RF_model: The RF model that is trained for predictions for the new cases 
    cls_target (0 or 1, int): The targeted class 

    Returns:
    An array of correctly predicted elements 
    """   
    predict = RF_model.predict(x)
    trg_cls = [target-predict[i] for i, target in enumerate(y) if target == cls_target]
    trg_cls = np.array(trg_cls)
    return np.shape(np.where(trg_cls==0))[1], len(trg_cls)

def query_RF(model, smiles1, smiles2):
    """
    Parameters
    ----------
    model : TYPE
        pre trained random forest model
    Smile1 : String
        Smile of first ligand
    Smile2 : String
        Smile of second ligand

    Returns
    -------
    Integer indicating the class of the compound.

    """
    fpSize = 4096 # This is the length of the fingerprint 
    radius= 5 # This identifies the no. of neighbors to be considered in building the fingerprints
    GA_fp = [mol_assemble(smiles1[i],smiles2[i],fpSize,radius) for i in range(len(smiles1))]
    X_test = pd.DataFrame(GA_fp)
    prediction= model.predict(X_test)
    return(prediction)

def RF_model(path_to_GA_file,path_to_training_X,path_to_training_Y):
    """
    Trains the RandomForestClassifier model and predicts the class each GA newly generated molecule belongs to.
    
    Parameters:
    path_to_GA_file (string): The path to GA generated molecules (GA_ligands.txt)
    path_to_original_dataset (string): The path to original dataset (fingerprints.csv and D_val.csv)
    
    Returns:
    An array of binary values indicating the class of each GA generated molecules.
    """

    fpSize = 4096 
    radius= 5 
    
    # Load the COMPASS dataset 
    xml = pd.read_csv(path_to_training_X, header=None)
    yml = pd.read_csv(path_to_training_Y, header=None)
    features = [x for x in xml.columns]
    yml = np.ravel(yml)
    
    # Read the newly generated smiles from the GA (it should have the smiles of 2 ligands for each compund)
    with open(path_to_GA_file, 'r') as file:
        content = file.readlines()

    # generate the fingerprints 
    GA_mol = [line.strip().split(' ') for line in content]
    GA_fp = [mol_assemble(smile1,smile2,fpSize,radius) for [smile1,smile2] in GA_mol]
    X_test = pd.DataFrame(GA_fp)
        
    # Checking if we have class imbalance in the COMPASS dataset 
    class_1_pop = sum(yml)*100/len(yml)
    print('Class 1 contribute to {:.1f} percent of the dataset'.format(class_1_pop))
    if not (35 <= class_1_pop <= 65):
        print ('Attention --------> We have class imbalance\n')
    
    # Dividing the dataset into training, validation sets 
    X_train, X_val, y_train, y_val = train_test_split(xml[features], yml, train_size = 0.8, random_state = RANDOM_STATE)
    
    
    print(f"the shape of the training set (input) is: {X_train.shape}")
    print(f"the shape of the cross validation set (input) is: {X_val.shape}")
    print(f"the shape of the test set (input) is: {X_test.shape}")
    
    # Training the RF model 
    RF_ml = RandomForestClassifier(n_estimators = 1000, 
                                   n_jobs = 8,
                                   class_weight = {1:1.25}, # This is the optimum class weight for a 45/55 balance in the COMPASS dataset 
                                   max_depth = 32, 
                                   min_samples_split = 50,
                                   random_state = RANDOM_STATE).fit(X_train,y_train)
    
    
    # Test the prediction accuracy 
    print(f"Metrics validation:\n\tAccuracy score: {accuracy_score(RF_ml.predict(X_val),y_val):.4f}\nMetrics train:\n\tAccuracy score: {accuracy_score(RF_ml.predict(X_train),y_train):.4f}")
    
    
    # Measure the true positives and negatives in the RF model prediction 
    true_pos, len_1 = true_predict(X_val,y_val,RF_ml,1)
    true_neg, len_0 = true_predict(X_val,y_val,RF_ml,0)
    print('The true positive is {:.4f} \nThe true negative is {:.4f}'.format(true_pos/len_1,true_neg/len_0))
    
    
    print('The walltime for the ml calculation is:{} s'.format((timeit.default_timer() - starttime)/1))
    
    predict = RF_ml.predict(X_test)
    print(predict)
    return predict, RF_ml


if __name__ == "__main__":
    #Test:
    predict, model = RF_model('/home/lion/Documents/GeneticAlgorithmDev/GA_test_2.txt','/home/lion/Documents/GeneticAlgorithmDev/fingerprints.csv','/home/lion/Documents/GeneticAlgorithmDev/D_val.csv')